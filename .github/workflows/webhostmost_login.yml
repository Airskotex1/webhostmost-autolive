# GitHub Actions 工作流名称
name: Monthly Webhostmost Login (Playwright)

# 工作流触发条件
on:
  # 允许手动触发
  workflow_dispatch:
  # 定时触发：每月20号的 UTC 时间 00:00 执行
  schedule:
    - cron: '0 0 20 * *' # UTC 时间每月20日0点0分

# 定义一个或多个作业
jobs:
  login:
    # 作业运行的环境
    runs-on: ubuntu-latest
    # 为作业设置权限
    permissions:
      contents: write # Mattraks/delete-workflow-runs 可能需要
      actions: write  # Mattraks/delete-workflow-runs 需要

    # 作业步骤
    steps:
      # 第一步：检出仓库代码
      - name: Checkout code
        uses: actions/checkout@v4

      # 第二步：删除旧的工作流运行记录
      - name: Delete workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 1 # 保留最近1天的工作流运行记录 (0会删除所有包括当前)
          keep_minimum_runs: 2 # 至少保留2个运行记录

      # 第三步：设置 Node.js 环境
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # 建议使用 LTS 版本，与您之前版本一致或更新

      # 第四步：安装依赖 (包括 Playwright 浏览器驱动)
      # npm install 会读取您仓库中的 package.json 文件
      # npx playwright install --with-deps chromium 会安装 chromium 和其依赖
      - name: Install dependencies and Playwright browsers
        run: |
          npm install 
          npx playwright install --with-deps chromium

      # 第五步：设置 WARP (可选，根据您的需求保留或移除)
      - name: Set up WARP
        uses: fscarmen/warp-on-actions@v1.3 # 使用您指定的版本
        with:
           stack: dual
           mode: client

      # 第六步：运行登录脚本
      - name: Run login script
        env:
          # 将 GitHub Secrets 传入环境变量
          USERNAMES_SECRET: ${{ secrets.USERNAMES }}
          PASSWORDS_SECRET: ${{ secrets.PASSWORDS }}
          # 用于通知的URL，如果需要配置，也可以放入Secret
          # NOTIFICATION_URL_BASE: "https://php.hipjs.cloudns.org/api/wxpush.php"
        run: |
          node <<'EOF'
          const { chromium } = require('playwright');
          const fs = require('fs'); // 用于文件系统操作，如创建截图目录

          // 异步函数：登录到 Webhostmost
          async function loginToWebHostMost(username, password, userIndex) {
            let browser;
            let context;
            let page;
            const screenshotDir = './screenshots'; // 截图保存目录
            if (!fs.existsSync(screenshotDir)){
                fs.mkdirSync(screenshotDir, { recursive: true }); // 创建截图目录
            }
            // 基础通知URL，您可以根据需要修改或从环境变量读取
            const notificationUrlBase = process.env.NOTIFICATION_URL_BASE || "https://php.hipjs.cloudns.org/api/wxpush.php";

            try {
              console.log(`[User ${userIndex + 1}] 正在尝试使用账户 ${username} 登录...`);
              // 启动 Playwright Chromium 浏览器
              browser = await chromium.launch({
                headless: true, // 在CI环境中通常使用无头模式
                args: [
                  '--no-sandbox',
                  '--disable-setuid-sandbox',
                  '--disable-dev-shm-usage',
                  '--disable-accelerated-2d-canvas',
                  '--no-first-run',
                  '--no-zygote',
                  '--disable-gpu'
                ]
              });
              context = await browser.newContext({
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                viewport: { width: 1280, height: 800 }
              });
              page = await context.newPage();

              // 导航到登录页面
              const loginUrl = 'https://webhostmost.com/login'; // 根据您的 login.js
              console.log(`[User ${userIndex + 1}] 正在导航到登录页面: ${loginUrl}`);
              await page.goto(loginUrl, { waitUntil: 'networkidle', timeout: 60000 }); // networkidle 等待网络基本空闲

              // CSS 选择器 (根据您的 login.js)
              const usernameSelector = 'input[name="username"]';
              const passwordSelector = 'input[name="password"]';
              const loginButtonSelector = 'button[type="submit"]';

              console.log(`[User ${userIndex + 1}] 等待用户名输入框加载...`);
              await page.waitForSelector(usernameSelector, { timeout: 30000 });
              console.log(`[User ${userIndex + 1}] 输入用户名: ${username}`);
              await page.fill(usernameSelector, username, { timeout: 10000 });

              console.log(`[User ${userIndex + 1}] 等待密码输入框加载...`);
              await page.waitForSelector(passwordSelector, { timeout: 30000 });
              console.log(`[User ${userIndex + 1}] 输入密码...`);
              await page.fill(passwordSelector, password, { timeout: 10000 });

              console.log(`[User ${userIndex + 1}] 等待登录按钮加载...`);
              await page.waitForSelector(loginButtonSelector, { timeout: 30000 });
              console.log(`[User ${userIndex + 1}] 点击登录按钮...`);
              
              // 点击登录按钮并等待导航完成
              // 使用 page.waitForURL 来确认跳转到了正确的页面
              const expectedUrlAfterLogin = 'https://webhostmost.com/clientarea.php'; // 根据您的 login.js
              await page.click(loginButtonSelector, { timeout: 10000 });
              
              console.log(`[User ${userIndex + 1}] 等待页面跳转到: ${expectedUrlAfterLogin}`);
              await page.waitForURL(expectedUrlAfterLogin, { timeout: 60000, waitUntil: 'domcontentloaded' });

              const currentUrl = page.url();
              console.log(`[User ${userIndex + 1}] 登录操作后当前URL: ${currentUrl}`);

              if (currentUrl.includes('clientarea.php')) {
                const successMessage = `用户 ${username} 登录成功！`;
                console.log(`[User ${userIndex + 1}] ${successMessage}`);
                try {
                  await page.goto(`${notificationUrlBase}?txt1=${encodeURIComponent(successMessage)}`, { timeout: 20000 });
                  console.log(`[User ${userIndex + 1}] 成功通知已发送。`);
                } catch (notifError) {
                  console.warn(`[User ${userIndex + 1}] 发送成功通知失败: ${notifError.message}`);
                }
              } else {
                const failureMessage = `用户 ${username} 登录后URL非预期。当前URL: ${currentUrl}`;
                console.warn(`[User ${userIndex + 1}] ${failureMessage}`);
                const screenshotPath = `${screenshotDir}/login-unexpected-page-${username.replace(/[^a-zA-Z0-9]/g, '_')}-${Date.now()}.png`;
                await page.screenshot({ path: screenshotPath, fullPage: true });
                console.log(`[User ${userIndex + 1}] 已保存截图: ${screenshotPath}`);
                // 不再发送失败通知，因为原始脚本只在捕获到错误时发送
              }

            } catch (error) {
              const errorMessage = `用户 ${username} 登录过程中发生错误: ${error.message}`;
              console.error(`[User ${userIndex + 1}] ${errorMessage}`);
              if (page) {
                const screenshotPath = `${screenshotDir}/login-error-${username.replace(/[^a-zA-Z0-9]/g, '_')}-${Date.now()}.png`;
                try {
                  await page.screenshot({ path: screenshotPath, fullPage: true });
                  console.log(`[User ${userIndex + 1}] 已保存错误截图: ${screenshotPath}`);
                } catch (screenshotError) {
                  console.error(`[User ${userIndex + 1}] 保存错误截图失败: ${screenshotError.message}`);
                }
              }
              // 发送失败通知
              try {
                // 确保page对象仍然可用或创建一个新的page对象来发送通知
                // 为简单起见，如果page对象可能已损坏，这里可以考虑不使用原page对象发送通知
                // 或者，如果通知服务允许，直接用 http.get 等方式发送
                if (page && !page.isClosed()) {
                     await page.goto(`${notificationUrlBase}?txt1=${encodeURIComponent(errorMessage.substring(0, 100))}`, { timeout: 20000 }); // 限制消息长度
                     console.log(`[User ${userIndex + 1}] 失败通知已发送。`);
                } else {
                     console.warn(`[User ${userIndex + 1}] Page closed or unavailable, skipping error notification via page.goto.`);
                     // 备用通知方法 (例如，使用 Node.js http模块)
                     // const http = require('https'); // or 'http'
                     // http.get(`${notificationUrlBase}?txt1=${encodeURIComponent(errorMessage.substring(0, 100))}`);
                }
              } catch (notifError) {
                console.warn(`[User ${userIndex + 1}] 发送失败通知失败: ${notifError.message}`);
              }
            } finally {
              if (context) {
                console.log(`[User ${userIndex + 1}] 关闭浏览器上下文 (${username})`);
                await context.close();
              }
              if (browser) { // 确保只在最外层循环后关闭浏览器，或每次都创建新浏览器
                // 在当前设计中，每个用户一个新浏览器实例，所以这里关闭是合适的
                console.log(`[User ${userIndex + 1}] 关闭浏览器实例 (${username})`);
                await browser.close();
              }
            }
          }

          // 主函数
          async function main() {
            const usernamesSecret = process.env.USERNAMES_SECRET;
            const passwordsSecret = process.env.PASSWORDS_SECRET;

            if (!usernamesSecret || !passwordsSecret) {
              console.error('错误：未设置 USERNAMES_SECRET 和/或 PASSWORDS_SECRET。请在 GitHub 仓库的 Secrets 中添加。');
              process.exit(1);
            }

            const usernames = usernamesSecret.split(',').map(u => u.trim()).filter(u => u);
            const passwords = passwordsSecret.split(',').map(p => p.trim()).filter(p => p);

            if (usernames.length === 0 || passwords.length === 0) {
              console.warn('警告：Secrets 中没有找到有效的账户信息。');
              return;
            }

            if (usernames.length !== passwords.length) {
              console.error('错误：用户名数量和密码数量不匹配。请检查 Secrets。');
              process.exit(1);
            }

            console.log(`共找到 ${usernames.length} 个账户信息。`);

            for (let i = 0; i < usernames.length; i++) {
              const username = usernames[i];
              const password = passwords[i];
              await loginToWebHostMost(username, password, i);
              if (i < usernames.length - 1) {
                console.log(`等待3秒后进行下一个账户登录...`);
                await new Promise(resolve => setTimeout(resolve, 3000)); // 短暂延迟
              }
            }
            console.log('所有账户的登录尝试已完成。');
          }

          main().catch(err => {
            console.error("脚本主函数执行失败:", err.message);
            process.exit(1);
          });
          EOF

      # 第七步：上传截图作为构建产物 (在作业失败或脚本记录了截图时)
      # 注意: if: always() 会在每次运行时都尝试上传，如果目录不存在会警告。
      # if: failure() 仅在作业失败时上传。
      # 为了确保即使脚本内部捕获错误并成功退出，截图也能上传，可以考虑更复杂的条件或始终上传。
      - name: Upload login screenshots
        if: always() # 无论成功失败都尝试上传，因为脚本内部可能生成截图
        uses: actions/upload-artifact@v4
        with:
          name: webhostmost-login-screenshots
          path: ./screenshots/ # 上传截图目录下的所有文件
          if-no-files-found: ignore # 如果没有文件，则忽略
